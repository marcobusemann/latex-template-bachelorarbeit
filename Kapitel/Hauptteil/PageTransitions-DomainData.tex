\subsection{Domain Data}
\label{pt-dd-main}
Jede View einer Anwendung zeigt in irgendeiner Form Inhalte an. Diese Inhalte können aus verschiedenen Quellen stammen und müssen in der Regel zum Zeitpunkt des Seitenwechsels vom Controller der View geladen werden. Je nachdem aus welcher Quelle diese Inhalte stammen, kann dieser Prozess eine gewisse Zeit in Anspruch nehmen. Lange Ladezeiten haben dadurch einen negativen Einfluss auf den Seitenwechsel und auch auf das Nutzererlebnis. In diesem Abschnitt werden daher Methoden betrachtet, die das Nutzererlebnis bei einem Seitenwechsel optimieren. Bei diesen Methoden wird auf eine Zeitmessung verzichtet, da das Laden der Daten in der Regel asynchron durchgeführt wird. Die Performance der betrachteten Methoden ist hier weniger von Interesse als der Zeitpunkt und die Art und Weise, wie Inhalte geladen werden. Stattdessen wird auf Basis von Vor- und Nachteilen argumentiert. Die ersten beiden Methoden haben allgemeinen Charakter und werden von der AngularJS Dokumentation oder von bekannten Entwicklern empfohlen. Die letzte Methode wurde im Rahmen dieser Arbeit erarbeitet und implementiert. 

\subsubsection{Router resolve}
\label{dd-router-resolve}
In AngularJS und Ionic werden die Seiten einer Anwendung durch Zustände beschrieben. Wie in Abschnitt \ref{pt-main} gezeigt, können für jeden Zustand Optionen, wie ein \gls{Template} oder ein Controller angegeben werden. Außerdem gibt es die Möglichkeit, über die Option \emph{resolve} eine Funktion zu hinterlegen. Durch diese Funktion lassen sich Daten per \gls{di} direkt in den Controller der Seite einfügen. Dieser Mechanismus funktioniert dabei nicht nur mit reinen Daten, sondern auch mit so genannten \glspl{Promise}. Die JavaScript Library CommonJS beschreibt einen Promise dabei wie folgt \cite{CommonJSPromises}:
\begin{quote}
"Promises provide a well-defined interface for interacting with an object that represents the result of an action that is performed asynchronously, and may or may not be finished at any given point in time."
\end{quote}
Mit einem \gls{Promise} kann demnach das Ergebnis einer asynchronen Funktion abgerufen werden. AngularJS wartet mit dem Seitenübergang, bis alle Abhängigkeiten in der Eigenschaft \emph{resolve} aufgelöst wurden. Dies beinhaltet das Warten auf Ergebnisse von einem \gls{Promise}. Wenn dieser \gls{Promise} fehlschlägt, sorgt AngularJS im gleichen Schritt dafür, dass der Seitenübergang nicht stattfindet. 
\\\\
Listing \ref{su-rr} zeigt die Implementierung der Option \emph{resolve}. In diesem Ausschnitt wird die Variable \emph{items} über \gls{di} in den Controller eingefügt. Diese Variable wird durch einen Service mit Beispieldaten befüllt. Die Methode \emph{doComsumeTime} des Service \emph{DummyService} liefert einen Promise und erstellt intern eine Liste von Items, die nach der angegebenen Zeit durch das \gls{Promise} Interface bereitgestellt werden. Wechselt der Anwender auf diese Seite der Anwendung, wartet AngularJS die angegebene Zeit, bevor der Seitenübergang durchgeführt wird.
\begin{lstlisting}[language=JavaScript, caption={Seitenübergänge, Router resolve}\label{su-rr}]
{ resolve: {
		items: function(DummyService) {
			return DummyService.doConsumeTime(2000 /*ms*/), 100);
}}};
app.controller('MyController', function($scope, items) {
	$scope.items = items;
});
\end{lstlisting}
Dieser Mechanismus hat den Vorteil, dass der Controller den Ursprung der Daten nicht kennt. Der Controller beinhaltet dadurch weniger Quellcode und die Lesbarkeit wird verbessert. Durch die fehlende Abhängigkeit zu anderen Komponenten der Anwendung ist der Controller einfacher zu testen. Als weiterer Vorteil wird häufig das automatische Abbrechen des Seitenüberganges im Falle eines Fehler in der \gls{Promise}-Ausführung gesehen. Hier stellt sich die Frage, ob es sinnvoller ist, eine allgemeine Fehlerseite anzuzeigen oder auf der Zielseite den Fehler im aktuellen Kontext zu behandeln \cite{JohnPapaResolveActivate}. 
\\\\
Der klare Nachteil dieses Mechanismus ist die Verzögerung des Seitenüberganges, bis alle Abhängigkeiten geladen wurden. Für den Anwender entstehen dabei Wartezeiten, die der Entwickler nur durch eine Ladeanimation überbrücken kann. Die Flexibilität, dem Anwender bei längeren Ladezeiten zunächst andere Informationen anzuzeigen, geht dabei verloren. Beispielsweise nutzt Facebook die Wartezeit dafür, dem Anwender ältere Beiträge anzuzeigen, bis neue Inhalte eintreffen.
\begin{table}[h]
	\centering
\begin{tabular}{l|l}
	\textbf{Vorteile} & \textbf{Nachteile} \\ \hline
	\begin{tabular}[c]{@{}l@{}}Leichtgewichtige Controller\\ - Herkunft der Daten unbekannt\\ - Einfacher zu testen\\ - Bessere Lesbarkeit\end{tabular} & \begin{tabular}[c]{@{}l@{}}Verzögerter \\ Seitenübergang\end{tabular} \\ \hline
	\begin{tabular}[c]{@{}l@{}}Seitenübergang wird abgebrochen, \\ wenn ein Promis fehlschlägt\end{tabular} & \begin{tabular}[c]{@{}l@{}}Geringe Flexibilität, die Wartezeit des \\ Anwenders zu überbrücken\end{tabular}
\end{tabular}
	\caption{Seitenübergänge, Domain Data, Vor- und Nachteile von Router resolve}
	\label{su-domaindata-vn-router-resolve}	
\end{table}

\subsubsection{Activation pattern}
Das Activation pattern ist ein Implementierungsdetail, um das Laden von Daten in einem AngularJS Controller zu vereinheitlichen. Das Ziel ist es, die Abhängigkeit zu Daten und Services in einer Funktion zu bündeln. Der Controller ist dadurch übersichtlicher und die Wartbarkeit wird verbessert. Außerdem ist das Aktualisieren der Daten durch den Aufruf dieser einen Funktion möglich. In diesem Pattern besitzt jeder Controller die Funktion \emph{activate()}. Diese Funktion wird beim Erstellen des Controller aufgerufen, um einmalig die Daten zu initialisieren. Das Laden der Daten findet beispielsweise über die Netzwerkschnittstelle von einem Backend statt. Listing \ref{su-ap} zeigt dieses Prinzip anhand desselben Beispiels wie im vorherigen Abschnitt.
\begin{lstlisting}[language=JavaScript, caption={Seitenübergänge, Activation pattern}\label{su-ap}]
app.controller('MyController', function($scope, DummyService) {
	$scope.items = [];
	activate();
	function activate() {
		DummyService.doConsumeTime(2000, 100).then(function(data) {
			$scope.items = data;
		});
	}
});
\end{lstlisting}
Der Vorteil im Vergleich zur Variante im vorherigen Abschnitt ist die große Flexibilität. Der Entwickler hat es selbst in der Hand, wann und welche Daten abgerufen und angezeigt werden. Die Nachteile entsprechen den Vorteilen der vorherigen Implementierung. Tests erfordern einen größeren Aufwand und ein tieferes Verständnis der Abläufe im Controller.
\begin{table}[h]
	\centering
	\begin{tabular}{l|l}
		\textbf{Vorteile} & \textbf{Nachteile} \\ \hline
		\begin{tabular}[c]{@{}l@{}}Direkter Seitenübergang\end{tabular} & Komplexere Tests \\ \hline
		Gute Lesbarkeit & \begin{tabular}[c]{@{}l@{}}Keine Trennung zwischen dem \\ Controller und der Herkunft der Daten\end{tabular} \\ \hline
		Einfacher Refresh-Mechanismus & \begin{tabular}[c]{@{}l@{}}Geringere Lesbarkeit\end{tabular} \\ \hline
		\begin{tabular}[c]{@{}l@{}}Hohe Flexibilität\\(Wann \& Welche Daten laden)\end{tabular} & 
	\end{tabular}
	\caption{Seitenübergänge, Domain Data, Vor- und Nachteile vom Activation pattern}	
	\label{su-domaindata-vn-activationpattern}
\end{table} 
Der große Unterschied in der Implementierung mit Activation-Pattern und Router Resolve liegt darin, dem Anwender Inhalte zu präsentieren, auch wenn die eigentliche Abfrage der Daten eine längere Zeit in Anspruch nimmt. Die Idee ist es, nach dem Seitenwechsel zunächst eine Untermenge der Daten anzuzeigen. Dies können ältere, sich  bereits im Cache befindliche Daten sein oder Daten, die sich schneller vom Backend abrufen lassen. Hier sind je nach Anwendungsfall verschiedene Szenarien möglich. Während dem Abrufen und Anzeigen dieser Untermenge wird die Abfrage der eigentlichen Daten durchgeführt. Für den Anwender beschleunigt sich dadurch der Seitenwechsel, weil ihm schneller Inhalte präsentiert werden. Listing \ref{su-ap-bsp} zeigt die Implementierung eines solchen Szenarios. Es werden zwei parallele Abfragen durchgeführt. In diesem Beispiel benötigt die erste Abfrage 400ms und die zweite 1600ms. Nach der Animation beim Seitenwechsel ist die erste Abfrage bereits durchgeführt und dem Anwender wird eine Liste der ersten 20 Elemente präsentiert. Währenddessen werden bereits die nächsten 80 Elemente geladen. Im besten Fall wurde die zweite Abfrage durchgeführt, bevor der Anwender beginnt, mit der Oberfläche zu interagieren. Obwohl die Abfrage in diesem Beispiel nach 100 Elementen 2000ms dauert, verzögert sich das Anzeigen der Inhalte nicht für das Nutzerempfinden.
\begin{lstlisting}[language=JavaScript, caption={Seitenübergänge, Activation pattern Anwendungsszenario}\label{su-ap-bsp}]
function activate() {
	// 20 Elemente in 400ms abrufen.
	DummyService.doConsumeTime(400, 20, $scope.items);
	// 80 Elemente in 1600ms abrufen
	DummyService.doConsumeTime(1600, 80, $scope.items);
}
\end{lstlisting}

\subsubsection{Vorzeitiges Laden von Daten}
Das dritte Verfahren befasst sich mit dem vorzeitigen Laden von Daten. Genau wie in Abschnitt \ref{pt-tp-main} für \glspl{Template} beschrieben, lässt sich diese Herangehensweise auch für Daten einer View anwenden. Das Verfahren sieht vor, zu einem bestimmten Zeitpunkt die Daten einer Seiten vorzeitig zu laden. Dabei wird vorausgesetzt, dass die Anwendung weiß, welche Daten benötigt werden oder dies zumindest aus Erfahrungswerten oder sonstigen Kriterien schließen kann. Für Listen, in denen jedes Element eine Detail-Seite besitzt, ist dieses Verfahren nur bedingt einsetzbar. Die Menge der verschiedenen Daten ist dabei zu groß. Der Ablauf, um dieses Verfahren zu implementieren umfasst die folgenden Schritte:
\begin{enumerate}
	\item Daten für Seite X abfragen (z.B. über HTTP beim Start der Anwendung)
	\item Daten für Seite X zwischenspeichern
	\item Benutzer wechselt zur Seite X
	\item Controller von Seite X ruft Daten aus dem Zwischenspeicher ab
	\item Controller von Seite X zeigt Daten in der View an
\end{enumerate}
Zu einem bestimmten Zeitpunkt werden die Daten der Seite abgefragt. Dies kann der Start der Anwendung oder der Wechsel zu einer Nachbarseite sein. Nachdem die Daten eingetroffen sind, werden sie an einer dafür vorgesehenen Stelle abgespeichert. Wechselt der Anwender nun zur Seite, kann dessen Controller die Daten aus dem Zwischenspeicher abrufen und in der View anzeigen. Problematisch wird es, wenn der Benutzer die Seite aufruft, die Daten jedoch noch nicht fertig geladen und zwischengespeichert wurden. Für die Zwischenspeicherung ist daher ein Cache erforderlich, der einerseits die Daten speichert und andererseits auf dem \gls{Promise} Pattern basiert. Der jeweilige Controller wartet dadurch beim Abfragen der Daten, bis diese tatsächlich eingetroffen sind. Anhang 1 zeigt einen generischen Cache, der diesen Anforderungen genügt. 
\begin{table}[h]
	\centering
	\begin{tabular}{l|l}
		\textbf{Vorteile} & \textbf{Nachteile} \\ \hline
		\begin{tabular}[c]{@{}l@{}}Direkter\\ Seitenübergang\end{tabular} & \begin{tabular}[c]{@{}l@{}}Maximale Anzahl\\ paralleler \\ XHR-Verbindungen beachten\end{tabular} \\ \hline
		Gute Lesbarkeit & \begin{tabular}[c]{@{}l@{}}Ungeeignet\\ bei stark Kontextbezogenen Seiten\end{tabular} \\ \hline
		Einfacher Refresh-Mechanismus &  \\ \hline
		\begin{tabular}[c]{@{}l@{}}Hohe Flexibilität\\ (Wann \& Welche Daten laden)\end{tabular} &  \\ \cline{1-1}
		\begin{tabular}[c]{@{}l@{}}Controller vom Laden \\ der Daten entkoppelt\end{tabular} &  \\ \cline{1-1}
		\begin{tabular}[c]{@{}l@{}}Geringe Ladezeiten durch die \\ Verlagerung von Netzwerkzugriffen\end{tabular} & 
	\end{tabular}
	\caption{Seitenübergänge, Domain Data, Vor- und Nachteile von Vorzeitigem Laden von Daten}	
	\label{su-domaindata-vn-dataprefetching}	
\end{table}
Der Cache wird durch einen AngularJS Service implementiert. Durch die Methode \emph{read()} werden Daten abgefragt und durch die Methode \emph{cache()} gespeichert. Die Daten werden jeweils unter einem bestimmten Schlüssel gespeichert, wodurch der Cache für beliebige Einsatzzwecke geeignet ist. Die Methode \emph{cache()} erwartet keinen Wert sondern einen \gls{Promise}. Sobald das Ergebnis dieses \gls{Promise} vorliegt, wird es im Cache abgelegt. Die Methode \emph{read()} liefert als Ergebnis nicht den eigentlichen Wert, sondern auch einen \gls{Promise}. Zunächst wird geprüft, ob die Daten schon im Cache vorliegen. Ist dies der Fall, wird der \gls{Promise} zurückgegeben und direkt abgeschlossen. Andernfalls werden die Daten über das \gls{Promise} Interface geliefert, sobald sie eintreffen. In Listing \ref{su-dp-usage} ist dieser Cache implementiert. In Kombination mit dem in Abschnitt \ref{pt-tp-main} vorgestellten Prinzip des Zustands-Graphen lassen sich Wartezeiten umfassend einsparen, da Netzwerkzugriffe bereits vor dem Besuchen der eigentlichen Seiten durchgeführt werden. 
\begin{lstlisting}[language=JavaScript, caption={Seitenübergänge, Vorzeitiges Laden von Daten mit generischem Cache}\label{su-dp-usage}]
// Daten anfordern, z.B. beim Start der Anwendung.
CacheService.cache('a', DummyService.doConsumeTime(2000, 100));
// Daten abrufen und anzeigen
function activate() {
	CacheService.read('a').then(applyItemsToController);
}
\end{lstlisting}

\subsubsection{Ergebnis}
Die beschriebenen Verfahren sind für unterschiedliche Einsatzszenarien geeignet. Je nach Anwendung muss das für den jeweiligen Fall passende Verfahren ausgewählt werden. Das für das Nutzererlebnis geeignetste Verfahren ist das vorzeitige Laden von Daten. Seitenübergänge können dabei ohne Verzögerung oder Ladeanzeigen durchgeführt werden. Wenn die Daten der einzelnen Seiten stark von vorherigen Benutzerentscheidungen abhängen, bietet sich das einfache Activation pattern an. Es ermöglicht im Vergleich die größte Flexibilität. Lediglich das Einsatzgebiet für Router resolve ist nach dieser Analyse im Hinblick auf das Nutzererlebnis klein.
