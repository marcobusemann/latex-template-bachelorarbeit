\mbchapter{Fazit}
Nachdem alle in dieser Arbeit betrachteten Best-Practice Lösungen beschrieben wurden, können nun die Ergebnisse als Erkenntnissammlung zusammengefasst werden. Bei der Entwicklung von Apps mit den in dieser Arbeit betrachteten Frameworks können diese Erkenntnisse dazu beitragen, schon während der Entwicklung eine gewisse Performance zu gewährleisten. Abhängig von verschiedenen Szenearien sind selbstverständlich weitere Optimierungen möglich bzw. erforderlich. Diese Erkenntnisse ermöglichen dennoch einen guten Überblick über die Möglichkeiten und das Optimierungspotential der Standardkomponenten von AngularJS und Ionic. 

\begin{itemize}
	\item \textbf{Dynamische Views}\\
	Der Einsatz von One-Time Bindings lohnt sich bereits bei ~60 beobachteten Werten auf einer Seite. Bei der Entwicklung von Apps für mobile Geräte ist es demnach sinnvoll, statische Daten unmittelbar als One-Time Binding zu markieren. Ressourcen werden dadurch bestmöglich geschont.
	
	\item \textbf{Modulare Views}\\
	Um mit AngularJS wiederverwendbare \gls{ui}-Komponenten zu schaffen, sollten aus Gründen der Kapselung und Flexibilität Direktiven gegenüber \emph{ngInclude} bevorzugt werden. Sie ermöglichen eine bessere Performance beim Einfügen in eine View. Dies gilt vor allem, wenn eine Komponente mehrfach, beispielsweise innerhalb einer Schleife, in einer View verwendet wird. 
	
	\item \textbf{Seitenübergänge - Templates}\\
	Um den ersten Aufruf einer Seite zu beschleunigen ist es sinnvoll, das vorzeitige Laden von \glspl{Template} anzuwenden. Dies gilt umso mehr, je größer das Template der Zielseite ist. Bei Anwendungen mit wenigen kritischen Seiten können Templates bereits beim Anwendungsstart abgefragt werden. Die maximale Anzahl so zu ladender Seiten sollte je nach Browser-Engine die Zahl 6 nicht überschreiten (siehe dazu Abschnitt \ref{browser-engines}). Bei komplexeren Anwendungen mit vielen kritischen Seiten, die zudem stark miteinander verbunden sind, lohnt sich die Definition eines gewichteten Graphen. Dadurch können beim Aufruf einer Seite benachbarte Seiten vorzeitig geladen werden.
	
	\item \textbf{Seitenübergänge - Daten}\\
	Der Zeitpunkt, an dem Daten für eine View geladen werden sollten, ist stark abhängig vom Kontext. Seiten, die mit einer großen Wahrscheinlichkeit vom Anwender aufgerufen werden können vorzeitiges Laden von Daten anwenden. Dies hat sich als die für den Seitenaufruf effektivste Variante herausgestellt. Dieses Verfahren ist jedoch nicht geeignet, wenn die auf der Seite gezeigten Daten stark von vorherigen Nutzereingaben abhängen. Stattdessen bietet sich aufgrund der Flexibilität das Activation-Pattern an. Sind Seitenaufrufe abhängig von Ergebnissen eines Promise, lohnt sich der Einsatz von Router-Resolve, um den Seitenaufruf im Fehlerfall abzubrechen. 
	
	\item \textbf{Listen}\\
	Für die Implementierung von Listen lohnt sich ab etwa 10 Elementen die \gls{vs} Technik. Sie bietet in allen untersuchten Bereichen, unabhängig von der Listengröße, eine konstant gute Performance. Alternativ sind statische oder dynamische Listen bei wenigen Elementen hinsichtlich der Performance ebenso geeignet. Sie sind darüber hinaus einfacher zu implementieren. In Einsatzszenarien, bei denen die Daten nicht von Anfang an vollständig vorliegen oder erst nach und nach eintreffen, ist die \gls{is} Technik sinnvoll. 
	
	\item \textbf{UI-Komponenten ausblenden}\\
	Um Bereiche einer View ein- und auszublenden, gibt es in AngularJS zwei Alternativen. Die Direktive \emph{ngIf} ermöglicht eine bessere Performance für Bereiche mit vielen Two-Way-Databindings. Sie ist jedoch langsamer beim Einfügen in die View. Die Direktive \emph{ngShow} ist hingegen performanter beim Einfügen und Ausblenden in eine View. Sie ist hingegen langsamer bei der Verwendung von Two-Way Databindings.\\
	Verwenden die Bereiche, die eingefügt oder entfernt werden sollen, viele Two-Way-Databindings, empfiehlt sich die Direktive \emph{ngIf}. Sollten diese Bereiche jedoch wiederholt ein- und ausgeblendet werden, ist \emph{ngShow} zu empfehlen.
	
	\item \textbf{Daten formatieren}\\
	Zur Anzeige von Daten in einer View müssen diese meist formatiert werden. Bei einfachen Werten wie einem Datum, einer Zahl oder einem String lohnt sich aufgrund des internen Caches von AngularJS der Einsatz von AngularJS Filtern. Für komplexe Werte wie Listen oder Objekte greift dieser Cache nicht. Für dieses Szenario ermöglicht eine manuelle Filterung mit manuellem Cache eine bessere Performance. 
\end{itemize}
Im Hinblick auf den Vergleich der beiden Android-Versionen 4.3 und 4.4.4 haben die Messungen in dieser Arbeit die anfänglichen Erwartungen nur zu einem Teil erfüllt. Bei einigen Messungen zeigt sich deutlich, dass Android 4.4.4 eine bessere Performance ermöglicht, bei anderen Messungen hingegen ist der umgekehrte Fall erkennbar. Betrachtet man die verschiedenen Tests, zeigt sich deutlich, dass Android 4.3 immer dann eine bessere Performance aufweist, wenn hauptsächlich die Manipulation des \gls{dom} eine Rolle spielt. Android 4.4.4 hingegen zeigt eine bessere Performance, wenn es um die reine JavaScript-Ausführung geht. Die generelle Aussage aus Kapitel \ref{plattformen}, dass mit der neuen Browser-Engine auch die Performance maßgeblich verbessert wurde, trifft demnach nicht vollständig zu. Eine spezielle Optimierung für ältere Android Versionen scheint demnach nicht essentiell notwendig zu sein. Dennoch sollte möglichst effizient entwickelt werden, um auch leistungsschwächere Geräte in allen Belangen als Zielgruppe zu erfassen. 
\\\\
Als Quellen wurden in dieser Arbeit hauptsächlich Internetseiten verwendet. Aufgrund der ständigen Weiterentwicklung der Frameworks gibt es keine aktuelle Literatur in Form von Büchern. Allein während der Durchführung dieses Projektes gab es Versionssprünge in AngularJS und Ionic, die aufgrund ihrer Relevanz zum Thema Performance Anpassungen erforderlich gemacht haben. Aus diesem Trend ergibt sich eine besondere Herausforderung für Unternehmen. Durch immer kürzere Release-Zyklen sind Unternehmen gefordert regelmäßig die Frameworks zu aktualisieren, um von Optimierungen und Fehlerkorrekturen in den Frameworks zu profitieren. Dadurch verlagert sich die Weiterentwicklung und Optimierung der Framework-Komponenten einer App von den Unternehmen auf die Framework-Hersteller. 
\\\\
Abschließend lässt sich sagen, dass durch das Projekt wertvolle Erkenntnisse für die Entwicklung performanter Apps mit AngularJS und Ionic gesammelt werden konnten. In zukünftigen Projekten werden diese Erkenntnisse dazu beitragen, performante Apps mit diesen Frameworks zu entwickeln. 
\\\\
Im Hinblick auf die Zukunft wird AngularJS ständig weiterentwickelt. Die Version 2.0 steht derzeit besonders im Fokus. Dabei handelt es sich um eine komplette Neuentwicklung auf Basis aktueller Technologien und Standards. AngularJS 2.0 verfolgt dabei den Grundsatz Mobile-First und soll dadurch vor allem für den Einsatz auf mobilen Geräten geeignet sein. Dies zeigt sich besonders in dem neuen Konzept für Two-Way-Databindings und dem Lazy-Loading von Komponenten. Die Anwendungslaufzeit soll durch diese Konzepte stark optimiert werden\cite{AJS20}. Es wird sich zeigen, ob die in dieser Arbeit vorgestellten Erkenntnisse, in der neuen Version weiterhin von Bedeutung sind oder bereits durch die neue Architektur obsolet werden.
